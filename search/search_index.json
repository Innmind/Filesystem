{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>This project expose a set of APIs allowing you to manipulate files and directories in a declarative way.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>composer require innmind/filesystem\n</code></pre>"},{"location":"case_sensitivity/","title":"Working with case insensitive filesystems","text":"<p>By default this package assumes you're working with a case sensitive filesystem, meaning you can have 2 files <code>a</code> and <code>A</code> inside a same directory. However this is not possible on a case insensitive filesystem (such as APFS on macOS), it will create only one of both.</p> <p>If you're dealing with a case insensitive filesystem then you need to specify it on the adapter like this:</p> <pre><code>use Innmind\\Filesystem\\{\n    Adapter\\Filesystem,\n    CaseSensitivity,\n};\nuse Innmind\\Url\\Path;\n\n$adapter = Filesystem::mount(Path::of('somewhere/'))\n    -&gt;withCaseSensitivity(CaseSensitivity::insensitive);\n$adapter instanceof Filesystem; // true, use $adapter as usual\n</code></pre> <p>If you persist user provided files on a filesystem you should use normalized names (like UUIDs) and keep the original names in a database to avoid collisions.</p>"},{"location":"philosophy/","title":"Philosophy","text":"<p>This package is designed around the declaration of how the filesystem should look like via immutable objects and objects that will apply such structure.</p> <p>The goal is that no matter the current state of the filesystem it will always create the directories and files you expect. No more <code>no such file or directory</code> errors.</p> <p>This design also brings benefits when reading data from the filesystem. The objects always force you to handle both case where the file/directory you want to access exists or not. This prevents runtime error where a file/directory you assumed axisted but does not.</p> <p>Reading a file content is also represented as an immutable object. By restricting the way you access the file content the package is able to only load the minimum amount of data in memory as you need. This way the package is able to handle any file size without running into memory issues.</p> <p>By having a separation between the data representation (as immutable objects) and the objects that will apply these structures, you can do handle your filesystem in a pure way. This means that you can test safely your code without having to rely on a concrete filesystem.</p>"},{"location":"philosophy/#terminology","title":"Terminology","text":""},{"location":"philosophy/#content","title":"<code>Content</code>","text":"<p>This class reprensents the ways to interact with a file content. In order to handle any file size it represent the data as a <code>Sequence</code> of lines or of chunks.</p> <p>Representing a file as a <code>Sequence</code> of lines is useful when dealing with text files, while the chunks approach will be useful for binary files.</p> <p>Your interactions with a file will mostly be described as what to do for each line/chunk. This way the package only needs to load one line/chunk at a time in memory.</p> <p>And because it uses a <code>Sequence</code> the data can come from anywhere. For example you can represent a file content with the results from a SQL query. There's no direct tie to a concrete filesystem.</p> Tip <p>And by using a lazy <code>Sequence</code> you can generate files larger that may not fit in the process memory.</p>"},{"location":"philosophy/#file","title":"<code>File</code>","text":"<p>A <code>File</code> is represented by a <code>Name</code>, a <code>Content</code> and a <code>MediaType</code>.</p> <p>Its <code>Name</code> is an immutable object. It uses an object and not a simple string in order to prevent the usage of invalid characters such as a directory separator or pseudo files <code>.</code> and <code>..</code>.</p> <p>Its <code>MediaType</code> is here mostly as an helper. There's no guarantee that the detected type when reading the file from the filesystem is the correct one. (1)</p> <ol> <li>It uses the PHP <code>mime_content_type</code> function internally.</li> </ol>"},{"location":"philosophy/#directory","title":"<code>Directory</code>","text":"<p>A directory is represented as a <code>Sequence</code> of <code>File</code>s or directories.</p> <p>Because it uses a <code>Sequence</code> the data can come from anywhere. That's why this package provides both a filesystem and in memory adapters and that an S3 adapter can be provided as an extension.</p> <p>This means that in order to access a file/directory from a directory via its name it will iterate over the <code>Sequence</code> until it finds the value. Bear in mind that depending on your filesystem structures this may cause performance issues as it will take longer to access a file/directory than a direct call to the filesystem by providing the path.</p> Tip <p>And by using a lazy <code>Sequence</code> you can generate large directory structures that may not fit in the process memory.</p>"},{"location":"philosophy/#adapter","title":"<code>Adapter</code>","text":"<p>An adapter is responsible to transform the immutable structures <code>Directory</code>/<code>File</code> to a concrete storage. And transform the raw data from the storage into <code>Sequence</code>s to represent back <code>Directory</code>/<code>File</code> structures.</p>"},{"location":"testing/in_app/","title":"In your application","text":"<p>In your application you'll use most of the time the <code>Filesystem</code> adapter but in your tests writing to the filesystem can be slow. Instead you can use the <code>InMemory</code> adapter.</p> <pre><code>use Innmind\\Filesystem\\Adapter\\InMemory;\n\n$filesystem = InMemory::emulateFilesystem();\n// use $filesystem as usual\n</code></pre> <p>This adapter is tested against the same properties as <code>Filesystem</code> to make sure there is no divergence of behaviour between the two.</p>"},{"location":"testing/own_adapter/","title":"Your own adapter","text":"<p>This library allows you to extend its behaviour by creating new implementations of the exposed interface <code>Adapter</code>. The interface is strict enough to guide you through the expected behaviour but the type system can't express all of them, leaving the door open to inconsistencies between implementations. That's why the library expose a set of properties (as declared by <code>innmind/black-box</code>) to help you make sure your implementations fulfill the expected behaviours.</p> <p>You can test properties on your adapter as follow:</p> <pre><code>use Properties\\Innmind\\Filesystem\\Adapter;\nuse Innmind\\BlackBox\\Set;\n\nreturn static function() {\n    yield properties(\n        'YourAdapter',\n        Adapter::properties(),\n        Set::call(fn() =&gt; /* instanciate YourAdapter here */),\n    );\n\n    foreach (Adapter::alwaysApplicable() as $property) {\n        yield property(\n            $property,\n            Set::call(fn() =&gt; /* instanciate YourAdapter here */),\n        )-&gt;named('YourAdapter');\n    }\n};\n</code></pre> <p>Then you can run your proofs via BlackBox.</p>"},{"location":"use_cases/backup_directory/","title":"Backup a directory","text":"<pre><code>use Innmind\\Filesystem\\Adapter\\Filesystem;\nuse Innmind\\Url\\Path;\n\n$source = Filesystem::mount(Path::of('/var/data/'));\n$backup = Filesystem::mount(Path::of('/volumes/backup/'));\n$source\n    -&gt;root()\n    -&gt;foreach(static fn($file) =&gt; $backup-&gt;add($file)-&gt;unwrap());\n</code></pre> <p>This example will copy all files and directories from <code>/var/data/</code> inside the folder <code>/volumes/backup/</code>. This operation is a merge and not an overwrite, meaning that files in the backup that don't exist in the source folder won't be deleted.</p>"},{"location":"use_cases/delete_file/","title":"Delete a file","text":""},{"location":"use_cases/delete_file/#at-the-root-of-the-adapter","title":"At the root of the adapter","text":"<pre><code>use Innmind\\Filesystem\\{\n    Adapter\\Filesystem,\n    Name,\n};\nuse Innmind\\Url\\Path;\n\n$filesystem = Filesystem::mount(Path::of('/var/data/'));\n$_ = $filesystem\n    -&gt;remove(Name::of('some file'))\n    -&gt;unwrap();\n</code></pre> <p>If the file doesn't exist it will do nothing and if the name corresponds to a directory it will remove the whole directory.</p>"},{"location":"use_cases/delete_file/#inside-a-directory","title":"Inside a directory","text":"<pre><code>use Innmind\\Filesystem\\{\n    Adapter\\Filesystem,\n    Name,\n    Directory,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\Predicate\\Instance;\n\n$filesystem = Filesystem::mount(Path::of('/var/data/'));\n$filesystem\n    -&gt;get(Name::of('some directory'))\n    -&gt;keep(Instance::of(Directory::class)) //(1)\n    -&gt;map(static fn($directory) =&gt; $directory-&gt;remove(Name::of('some file')))\n    -&gt;match(\n        static fn($directory) =&gt; $filesystem-&gt;add($directory)-&gt;unwrap(), //(2)\n        static fn() =&gt; null,\n    );\n</code></pre> <ol> <li>make sure we are dealing with a directory</li> <li>the file will be removed here only</li> </ol> <p>This example will remove the file <code>some file</code> inside the directory <code>some directory</code>. If the directory doesn't exist or <code>some directory</code> is not a directory then nothing will happen.</p>"},{"location":"use_cases/load_ftp_files/","title":"Load FTP files","text":"<p>Say you have a client that push csv files in an unstructured manner inside a FTP directory. You can load all files like so:</p> <pre><code>use Innmind\\Filesystem\\{\n    Adapter\\Filesystem,\n    File,\n    Directory,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\Sequence;\n\n/**\n * @return Sequence&lt;File&gt;\n */\nfunction flatten(File|Directory $file): Sequence\n{\n    if ($file instanceof Directory) {\n        // bring all the files from sub directories to the same level\n        return $file-&gt;all()-&gt;flatMap(flatten(...));\n    }\n\n    return Sequence::of($file);\n}\n\nFilesystem::mount(Path::of('/path/to/ftp/directory/'))\n    -&gt;root()\n    -&gt;all()\n    -&gt;flatMap(flatten(...))\n    -&gt;foreach(static fn(File $csv) =&gt; doYourStuff($csv));\n</code></pre> <p>The advantage of this approach is that you can easily test the whole program behaviour by replacing the <code>Filesystem</code> adapter by a <code>InMemory</code> one.</p>"},{"location":"use_cases/modify_file/","title":"Modify a file","text":"<p>You can't modify a file in place, meaning you can't read and write to the same file at once. You need to write to a different file first.</p>"},{"location":"use_cases/modify_file/#replace-a-line","title":"Replace a line","text":"<pre><code>use Innmind\\Filesystem\\{\n    Adapter\\Filesystem,\n    File,\n    Name,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\{\n    Str,\n    Predicate\\Instance,\n};\n\n// replace the \"unreleased\" title with the new version\n$insertRelease = static function(Str $line): Str {\n    if ($line-&gt;startsWith('## [Unreleased]')) {\n        return Str::of('## 1.0.0 - 2022-01-30');\n    }\n\n    return $line;\n};\n// replace the old changelog with the new one containing\n// the new release version\n$release = static function(File $changelog) use ($insertRelease): File {\n    return $changelog-&gt;mapContent(\n        static fn($content) =&gt; $content-&gt;map(\n            static fn($line) =&gt; $line-&gt;map($insertRelease),\n        ),\n    );\n}\n$filesystem = Filesystem::mount(Path::of('some/repository/'));\n$tmp = Filesystem::mount(Path::of('/tmp/'));\n$filesystem\n    -&gt;get(Name::of('CHANGELOG.md'))\n    -&gt;keep(Instance::of(File::class))\n    -&gt;map($release)\n    -&gt;flatMap(static function($changelog) use ($tmp) {\n        // this operation is due to the fact that you cannot read and\n        // write to the same file at once\n        $tmp-&gt;add($changelog)-&gt;unwrap();\n\n        return $tmp-&gt;get($changelog-&gt;name());\n    })\n    -&gt;match(\n        static fn($changelog) =&gt; $filesystem-&gt;add($changelog)-&gt;unwrap(),\n        static fn() =&gt; null, // the changelog doesn't exist\n    );\n</code></pre> <p>This example modifies the <code>CHANGELOG.md</code> file to replace the <code>## [Unreleased]</code> title with a version number.</p>"},{"location":"use_cases/modify_file/#insert-a-new-line","title":"Insert a new line","text":"<pre><code>use Innmind\\Filesystem\\{\n    Adapter\\Filesystem,\n    File,\n    File\\Content,\n    File\\Content\\Line,\n    Name,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\{\n    Sequence,\n    Str,\n    Predicate\\Instance,\n};\n\n// Insert \"Jane Doe\" after the user \"John Doe\"\n$updateUser = static function(Line $user): Content {\n    if ($user-&gt;toString() === 'John Doe') {\n        return Content::ofLines(Sequence::of(\n            $user,\n            Line::of(Str::of('Jane Doe')),\n        ));\n    }\n\n    return Content::ofLines(Sequence::of($user));\n};\n$update = static function(File $users) use ($updateUser): File {\n    return $users-&gt;mapContent(\n        static fn($content) =&gt; $content-&gt;flatMap(static fn($line) =&gt; $updateUser($line)),\n    );\n};\n$filesystem = Filesystem::mount(Path::of('/var/data/'));\n$tmp = Filesystem::mount(Path::of('/tmp/'));\n$filesystem\n    -&gt;get(Name::of('users.csv'))\n    -&gt;keep(Instance::of(File::class))\n    -&gt;map($update)\n    -&gt;flatMap(static function($users) use ($tmp) {\n        // this operation is due to the fact that you cannot read and\n        // write to the same file at once\n        $tmp-&gt;add($users)-&gt;unwrap();\n\n        return $tmp-&gt;get($users-&gt;name());\n    })\n    -&gt;match(\n        static fn($users) =&gt; $filesystem-&gt;add($users)-&gt;unwrap(),\n        static fn() =&gt; null, // the csv doesn't exist\n    );\n</code></pre> <p>This example will insert the user <code>Jane Doe</code> after <code>John Doe</code> wherever he is in the <code>users.csv</code> file. If the file doesn't exist then nothing happens.</p>"},{"location":"use_cases/modify_file/#merge-two-files","title":"Merge two files","text":"<pre><code>use Innmind\\Filesystem\\{\n    Adapter\\Filesystem,\n    File,\n    File\\Content,\n    Name,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\{\n    Maybe,\n    Predicate\\Instance,\n};\n\n$merge = static function(File $file1, File $file2): File {\n    return File::named(\n        'all_users.csv',\n        Content::ofLines(\n            $file1-&gt;content()-&gt;lines()-&gt;append(\n                $file2-&gt;content()-&gt;lines(),\n            ),\n        ),\n    );\n};\n$filesystem = Filesystem::mount(Path::of('/var/data/'));\n$users1 = $filesystem\n    -&gt;get(Name::of('users1.csv'))\n    -&gt;keep(Instance::of(File::class));\n$users2 = $filesystem\n    -&gt;get(Name::of('users2.csv'))\n    -&gt;keep(Instance::of(File::class));\nMaybe::all($users1, $users2)\n    -&gt;map(static fn($file1, $file2) =&gt; $merge($file1, $file2))\n    -&gt;match(\n        static fn($merged) =&gt; $filesystem-&gt;add($merged)-&gt;unwrap(),\n        static fn() =&gt; null,\n    );\n</code></pre> <p>This example will create a file <code>all_users.csv</code> containing both files <code>users1.csv</code> and <code>users2.csv</code>. If one of the files or both of them doesn't exist then the new file won't be created.</p>"},{"location":"use_cases/persist_hand_file/","title":"Persist a file created by hand","text":""},{"location":"use_cases/persist_hand_file/#create-an-empty-file","title":"Create an empty file","text":"<pre><code>use Innmind\\Filesystem\\{\n    Adapter\\Filesystem,\n    File,\n    File\\Content,\n};\nuse Innmind\\Url\\Path;\n\n$filesystem = Filesystem::mount(Path::of('/var/data/'));\n$_ = $filesystem\n    -&gt;add(File::named('some name'), Content::none())\n    -&gt;unwrap();\n</code></pre> <p>This is equivalent of running the cli command <code>touch '/var/data/some name'</code>.</p>"},{"location":"use_cases/persist_hand_file/#create-a-file-with-some-content","title":"Create a file with some content","text":"<pre><code>use Innmind\\Filesystem\\{\n    Adapter\\Filesystem,\n    File,\n    File\\Content,\n    File\\Content\\Line,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\{\n    Sequence,\n    Str,\n};\n\n$filesystem = Filesystem::mount(Path::of('/var/data/'));\n$_ = $filesystem\n    -&gt;add(File::named(\n        'some name',\n        Content::ofLines(Sequence::of(\n            Line::of(Str::of('first line')),\n            Line::of(Str::of('second line')),\n            Line::of(Str::of('etc...')),\n        ))\n    ))\n    -&gt;unwrap();\n</code></pre> <p>When the file is persisted the end of line character will be automatically added for you.</p>"},{"location":"use_cases/persist_hand_file/#create-a-file-inside-a-directory","title":"Create a file inside a directory","text":"<pre><code>use Innmind\\Filesystem\\{\n    Adapter\\Filesystem,\n    File,\n    File\\Content,\n    Directory,\n};\nuse Innmind\\Url\\Path;\n\n$filesystem = Filesystem::mount(Path::of('/var/data/'));\n$_ = $filesystem\n    -&gt;add(\n        Directory::named('whatever')-&gt;add(\n            File::named(\n                'some name',\n                Content::none(),\n            ),\n        ),\n    )\n    -&gt;unwrap();\n</code></pre> <p>This is equivalent of running the cli command <code>touch '/var/data/whatever/some name'</code>.</p>"},{"location":"use_cases/persist_process_output/","title":"Persist a process output","text":"<p>This example uses the <code>innmind/operating-system</code> package.</p> <pre><code>use Innmind\\Filesystem\\{\n    File,\n    File\\Content,\n    Adapter\\Filesystem,\n};\nuse Innmind\\OperatingSystem\\Factory;\nuse Innmind\\Server\\Control\\Server\\Command;\nuse Innmind\\Url\\Path;\n\n$os = Factory::build();\n$filesystem = Filesystem::mount(Path::of('/var/data/'));\n$fileContent = Content::ofChunks(\n    $os\n        -&gt;control()\n        -&gt;processes()\n        -&gt;execute(\n            Command::of('gzip')\n                -&gt;withShortOption('d')\n                -&gt;withArgument('some-archive.txt.tar.gz'),\n        )\n        -&gt;output()\n        -&gt;chunks()\n        -&gt;map(static function($pair) {\n            [$chunk, $type] = $pair;\n\n            return $chunk;\n        }),\n);\n$filesystem\n    -&gt;add(\n        File::named(\n            'some-archive.txt',\n            $fileContent,\n        ),\n    )\n    -&gt;unwrap();\n</code></pre>"},{"location":"use_cases/persist_uploaded_file/","title":"Persist an uploaded file","text":"<pre><code>use Innmind\\Filesystem\\{\n    File,\n    File\\Content,\n    Directory,\n    Adapter\\Filesystem,\n    Name,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\Predicate\\Instance;\n\n$tmp = Filesystem::mount(Path::of(\\dirname($_FILES['my_upload']['tmp_name'])));\n$filesystem = Filesystem::mount(Path::of('/var/data/'));\n\n$_ = $tmp\n    -&gt;get(Name::of(\\basename($_FILES['my_upload']['tmp_name'])))\n    -&gt;keep(Instance::of(File::class))\n    -&gt;map(static fn($file) =&gt; $file-&gt;rename(\n        Name::of($_FILES['my_upload']['name']),\n    ))\n    -&gt;map(Directory::named('uploads')-&gt;add(...))\n    -&gt;match(\n        $filesystem-&gt;add(...),\n        static fn() =&gt; null, // the file doesn't exist somehow\n    )\n    ?-&gt;unwrap();\n</code></pre>"},{"location":"use_cases/read_file/","title":"Read a file from the filesystem","text":""},{"location":"use_cases/read_file/#at-the-root-of-the-adapter","title":"At the root of the adapter","text":"<pre><code>use Innmind\\Filesystem\\{\n    Adapter\\Filesystem,\n    File,\n    Name,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\Predicate\\Instance;\n\n$print = static function(File $file): void {\n    $file\n        -&gt;content()\n        -&gt;foreach(function($line) {\n            echo $line-&gt;toString().\"\\n\";\n        });\n};\n\n$filesystem = Filesystem::mount(Path::of('/var/data/'));\n$filesystem\n    -&gt;get(Name::of('some file'))\n    -&gt;keep(Instance::of(File::class))\n    -&gt;match(\n        static fn(File $file) =&gt; $print($file),\n        static fn() =&gt; null, // the file doesn't exist\n    );\n</code></pre> <p>This example will print each line to the screen, or nothing if the file doesn't exist.</p>"},{"location":"use_cases/read_file/#inside-a-directory","title":"Inside a directory","text":"<pre><code>use Innmind\\Filesystem\\{\n    Adapter\\Filesystem,\n    File,\n    Name,\n    Directory,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\Predicate\\Instance;\n\n$print = static function(File $file): void {\n    $file\n        -&gt;content()\n        -&gt;foreach(function($line) {\n            echo $line-&gt;toString().\"\\n\";\n        });\n};\n\n$filesystem = Filesystem::mount(Path::of('/var/data/'));\n$filesystem\n    -&gt;get(Name::of('some directory'))\n    -&gt;keep(Instance::of(Directory::class)) //(1)\n    -&gt;flatMap(static fn($directory) =&gt; $directory-&gt;get(Name::of('some file')))\n    -&gt;match(\n        static fn(File $file) =&gt; $print($file),\n        static fn() =&gt; null, // the file doesn't exist\n    );\n</code></pre> <ol> <li>make sure \"some directory\" is not a file</li> </ol> <p>This example will print each line to the screen, or nothing if the file doesn't exist or if <code>some directory</code> is a file and not a directory or <code>some directory</code> doesn't exist.</p>"}]}